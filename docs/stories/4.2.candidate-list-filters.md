# Story 4.2: Candidate List Filters

## Status

DONE

## Story

**As a** recruiter,  
**I want** to filter the candidate list by tags and other criteria,  
**so that** I can narrow down to relevant candidates.

## Acceptance Criteria

1. Filter panel on candidates list page (sidebar or collapsible)
2. Filter by tags: multi-select from existing tags
3. Tag filter logic: AND (candidate must have ALL selected tags)
4. Filter by city: text input with autocomplete from existing cities
5. Clear filters button to reset all
6. Active filters displayed as chips above the list
7. Remove individual filter by clicking X on chip
8. Filtered count displayed: "X candidats trouvés"
9. Filters persist during session (not on page reload)
10. URL query params reflect active filters (shareable filtered views)

**Réf.** Wireframes §2 Liste Candidats (filtres Tags, Ville, chips actifs, « Effacer filtres »).

## Tasks / Subtasks

- [x] Task 1 (AC: 2, 3): API – Étendre candidate.list pour les filtres tags
  - [x] Étendre `candidateListInputSchema` dans `src/lib/validations/candidate.ts` : ajouter `tagIds?: string[]` (tableau d’UUID de tags). [Source: docs/architecture/coding-standards.md §3]
  - [x] Dans `candidate.list`, si `tagIds` fourni : ajouter AND avec `tags: { some: { tagId } }` pour chaque tag (logique AND). [Source: prisma/schema.prisma, CandidateTag]
  - [x] S’assurer que le filtre reste scopé par `companyId` (les tags sont déjà scopés par company). [Source: docs/architecture.md §4]
- [x] Task 2 (AC: 4): API – Filtre ville et liste des villes distinctes
  - [x] Étendre `candidateListInputSchema` : ajouter `city?: string` (chaîne optionnelle, trim). [Source: docs/architecture/coding-standards.md §3]
  - [x] Dans `candidate.list`, si `city` fourni : ajouter `city: { equals: city, mode: 'insensitive' }`. [Source: prisma/schema.prisma, Candidate.city]
  - [x] Créer procédure `candidate.listDistinctCities` (protectedProcedure). [Source: docs/architecture/source-tree.md]
- [x] Task 3 (AC: 1, 2, 4, 5): Composant panneau de filtres
  - [x] Créer `src/components/candidates/CandidateListFilters.tsx` : panneau avec filtre Tags (Popover multi-select) et filtre Ville (input + datalist). [Source: docs/wireframes.md §2 Liste Candidats]
  - [x] Tags : utiliser `tag.list` ; multi-select Popover + checkboxes. [Source: tag router, docs/frontend-architecture.md §4]
  - [x] Ville : input avec datalist, options depuis `candidate.listDistinctCities`. [Source: wireframes §2]
  - [x] Bouton « Effacer filtres » : réinitialise tags et ville. [Source: PRD AC 5]
  - [x] Props : `filters`, `onFiltersChange`, `onClear`. [Source: docs/frontend-architecture.md §4.2]
- [x] Task 4 (AC: 6, 7, 8): Chips actifs et comptage
  - [x] Créer `ActiveFilterChips.tsx` : chips « Tag: X », « Ville: Y » avec X pour retirer. [Source: wireframes §2]
  - [x] Affichage « X candidats trouvés » : utiliser le nombre d’items retournés par la query (ou total si pagination). Pour pagination cursor-based avec filtres, le total exact peut être coûteux ; afficher « X candidats » sur la page courante ou ajouter un champ `total` optionnel dans la réponse. [Source: PRD AC 8]
- [x] Task 5 (AC: 9, 10): Synchronisation avec l’URL
  - [x] Utiliser `useSearchParams` et `useRouter` pour lire/écrire les filtres dans l’URL (`?tags=id1,id2&city=Paris`). [Source: docs/frontend-architecture.md §3.2]
  - [x] À l’initialisation, lire les query params et les appliquer aux filtres. À chaque changement de filtre, mettre à jour l’URL (sans rechargement complet). [Source: PRD AC 10]
  - [x] AC 9/10 : avec URL params, les filtres persistent au rechargement (partage de vue). [Source: frontend-architecture §3.2]
- [x] Task 6: Intégration dans la page candidats
  - [x] Intégrer `CandidateListFilters` et `ActiveFilterChips` dans `src/app/(dashboard)/candidates/page.tsx`. [Source: docs/stories/2.1]
- [x] Task 7 – Testing (AC: 1–10)
  - [x] Tests d'intégration : `candidate.list` tagIds (AND), city ; `listDistinctCities` ; isolation multi-tenant. [Source: docs/architecture.md §14]
  - [x] Tests unitaires : `candidateListInputSchema` (tagIds, city).
- [x] Task 8 (QA): Rédiger les cas de test dans un fichier dédié (ex. docs/stories/cases/4.2-test-cases.md) pour faciliter la review de la story.
- [x] Task 9 (review): Lancer une review de code en fin de développement avant clôture de la story.

## Dev Notes

### Previous Story Insights

- Story 4.1 DONE : barre de recherche globale, router search, page /search. La liste candidats actuelle (`candidates/page.tsx`) utilise `candidate.list` avec `limit` et `cursor` ; pas de filtres. [Source: docs/stories/4.1, candidates/page.tsx]
- Le router `tag` expose déjà `tag.list` pour l’autocomplete. [Source: src/server/trpc/routers/tag.ts]
- Le schéma `candidateListInputSchema` actuel : `cursor`, `limit`. [Source: src/lib/validations/candidate.ts]

### Data Models

- **Candidate** : id, city, companyId. Relation `tags` (CandidateTag) vers Tag. [Source: prisma/schema.prisma]
- **CandidateTag** : candidateId, tagId. Relation tag (Tag). [Source: prisma/schema.prisma]
- **Tag** : id, name, color, companyId. [Source: prisma/schema.prisma]
- Logique AND tags : un candidat doit avoir TOUS les tags sélectionnés. Prisma : `tags: { every: { tagId: { in: tagIds } } }` — attention : `every` sur une relation vide retourne true. Pour « candidat a au moins les tags tagIds », utiliser `tags: { some: { tagId: { in: tagIds } } }` avec un count, ou `AND: tagIds.map(id => ({ tags: { some: { tagId: id } } }))`. Vérifier la sémantique : « must have ALL selected tags » = pour chaque tagId sélectionné, le candidat doit avoir ce tag. Donc `AND: tagIds.map(tagId => ({ tags: { some: { tagId } } }))`. [Source: Prisma docs]

### API Specifications

- **candidate.list** (extended) : input `{ cursor?, limit, tagIds?: string[], city?: string }`. Filtre where : `AND` de companyId, (si tagIds) condition tags, (si city) condition city. [Source: docs/architecture.md §9]
- **candidate.listDistinctCities** (new) : protectedProcedure, retourne `string[]` (villes distinctes non nulles du cabinet). [Source: docs/architecture/source-tree.md]
- Pas de rate limiting pour ces endpoints (lecture). [Source: docs/architecture/rate-limiting.md]

### Component Specifications

- Panneau filtres : sidebar ou section collapsible. Sur desktop, peut être une colonne à gauche ; sur mobile, bouton « Filtres » ouvrant un drawer. [Source: wireframes §2]
- Tags multi-select : Popover avec liste de checkboxes (tag.list), ou Select multiple shadcn. [Source: docs/design-system.md]
- Ville : Input avec Combobox ou datalist, options depuis listDistinctCities. Recherche/filtrage côté client si beaucoup de villes. [Source: wireframes §2]
- Chips : Badge avec label + X (Bade x ou composant custom). Design System palette. [Source: docs/design-system.md §2]

### File Locations

| Purpose                    | Path                                               |
| -------------------------- | -------------------------------------------------- |
| Validations candidate list | src/lib/validations/candidate.ts                   |
| Router candidate           | src/server/trpc/routers/candidate.ts               |
| Composant filtres          | src/components/candidates/CandidateListFilters.tsx |
| Page candidats             | src/app/(dashboard)/candidates/page.tsx            |

[Source: docs/architecture/source-tree.md]

### Technical Constraints

- Pagination cursor-based : avec filtres, le cursor reste valide car l’ordre (createdAt desc) est stable. Les filtres réduisent l’ensemble résultant. [Source: architecture existante]
- Logique AND pour les tags : « candidate must have ALL selected tags ». Implémentation Prisma : `AND: tagIds.map(tagId => ({ tags: { some: { tagId } } }))`. [Source: PRD AC 3]

### Testing

- Intégration : candidate.list avec tagIds (1 tag, 2 tags), city ; listDistinctCities ; isolation companyId. [Source: docs/architecture.md §14]

### Project Structure Notes

- Pas de conflit. Le composant CandidateListFilters complète la page existante.

---

## Change Log

| Date       | Version | Description                                                                                    | Author      |
| ---------- | ------- | ---------------------------------------------------------------------------------------------- | ----------- |
| 2026-02-21 | 0.1     | Story draft created (4.2 Candidate List Filters)                                               | Bob (SM)    |
| 2026-02-21 | 0.2     | Implementation complete: API filters, CandidateListFilters, ActiveFilterChips, URL sync, tests | James (Dev) |

---

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (via Cursor)

### Debug Log References

N/A

### Completion Notes List

- Filtres dérivés de l'URL (useMemo) pour éviter setState dans useEffect (règle lint react-hooks/set-state-in-effect).
- Logique AND pour les tags : `AND: tagIds.map(tagId => ({ tags: { some: { tagId } } }))` (candidat doit avoir chaque tag).
- Comptage « X candidats trouvés » : nombre d'items de la page courante (pas de count API séparé).

### File List

| Action   | Path                                               |
| -------- | -------------------------------------------------- |
| Modified | src/lib/validations/candidate.ts                   |
| Modified | src/server/trpc/routers/candidate.ts               |
| Created  | src/components/candidates/CandidateListFilters.tsx |
| Created  | src/components/candidates/ActiveFilterChips.tsx    |
| Modified | src/app/(dashboard)/candidates/page.tsx            |
| Modified | tests/unit/validations/candidate.test.ts           |
| Modified | tests/integration/candidate/candidate.test.ts      |
| Created  | docs/stories/cases/4.2-test-cases.md               |

---

## QA Results

_(Results from QA Agent review of the completed story implementation.)_
